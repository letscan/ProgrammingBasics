.. default-role:: code


处理多种情况
============

.. hint::

    阅读本章之前，请先确认你已经熟悉下列概念： ::

        函数 输入 输出 布尔值

    如果有任何疑问，请重新阅读前面的章节。


分而治之
--------

我们已经学习了基本的程序设计方法。但在具体实现函数的阶段，往往会遇到困难，无法顺利完成回溯。例如下面的简单题目。

.. topic:: 实例：二者中的最大值

    实现函数 ``max()`` 的简化版 ``max2()`` 。输入限定为只有2个数值，不多不少。请输出二者中较大的一个。

关于输入输出，题目已经描述的非常明确。我们姑且决定2个参数名字分别为 ``a`` 和 ``b`` ，返回值名字为 ``m`` ，然后直接写出函数框架：

    ::

        def max2(a, b):
            m = ... a ... b ...
            return m

但也就到此为止了。要从 ``a`` 和 ``b`` 得到 ``m`` ，除了使用 ``max()`` 这种明显犯规的方法，实在是无法可想。

这时我们需要转变一下思路， ``m`` 并非一定要用某个函数从 ``a`` 和 ``b`` 得出。这道题目其实太过简单，事实上，只有 ``m = a`` 和 ``m = b`` 这两种可能性。即使我们直接指定 ``m = a`` ，函数也有大约一半的机会得出正确结果；直接指定 ``m == b`` ，就能在另一半的机会得出正确结果。如果我们能够同时表达出这两种可能性，应该就可以在所有情况下得出正确结果了吧。

类似情形在实际应用中并不少见。为此，Python和其它编程语言都提供了适当的机制，允许我们同时表达这2种可能的代码。但凡遇到这种情况，我们可以像下面这样，把对应2种可能性的代码都放进函数：

    ::

        def max2(a, b):
            if ... ① ... :
                m = a
            else:
                m = b
            return m

可以看到，被 ``if`` 和 ``else`` 分隔开的两个代码块，分别表达了 ``m = a`` 和 ``m = b`` 这两种可能性。这个结构表示，在某些情况下，程序只会执行 ``if`` 对应的代码块，其它的情况下则只会执行 ``else`` 对应的代码块。在给定的条件下，两个代码块只会有一个被执行，不多不少。具体来说，Python要求我们在 ``if`` 后面①的位置填上一个返回布尔值的函数或运算。如果函数或运算返回的布尔值为 ``True`` 时，就只会执行 ``if`` 下面的代码块；如果返回的布尔值为 ``False`` ，就只会执行 ``else`` 下面的代码块。

因此，现在我们只要在 ``if`` 后面①处填上适当内容，指出在何种情况下应该执行 ``m = a`` ，就可以完成函数。这里我们就选择最简单的方法：

    ::

        def max2(a, b):
            if a > b:
                m = a
            else:
                m = b
            return m

这表示当 ``a > b`` 时，被执行的将会是 ``m = a`` ；而 ``a > b`` 以外的情况，无论 ``a`` 小于还是等于 ``b`` ，被执行的都将会是 ``m = b`` 。这就是 ``max2()`` 的完成版本。

.. topic:: Exercise

    使用不同的参数验证 ``max2()`` 的执行结果是否正确。请思考为什么无论 ``a`` 小于还是等于 ``b`` ，执行 ``m = b`` 都是正确的选择？

在上面的例子中，我们根据输出只存在2种可能性这一事实，在函数内部构造了2条 *分支* ，每个分支中对应一种可能性，以及这种可能性下应当执行的代码。构造分支的方法，就是用 ``if ... else ...`` 将函数内部分成2个代码块，并分别填上2种可能的代码，最后给出执行其中一条分支的条件。

如果我们发现存在3种或更多的可能性，可以使用 ``elif`` （else if的缩写）来添加更多的分支。例如：

    ::

        def func( ... ):
            ...
            if c1:
                ...
            elif c2:
                ...
            elif c3:
                ...
            else:
                ...
            ...

像上面这样的代码运行时，会依次判断每个 ``if`` 或 ``elif`` 后面的布尔值，然后只会执行遇到的 **第一个** 等于 ``True`` 的布尔值所对应的代码块。这意味着等于 ``False`` 的布尔值对应的代码块，或是虽等于 ``True`` 但并非 **第一个** 等于 ``True`` 的布尔值对应的代码块，都不会被执行。后一点尤其值得注意。

.. topic:: 实例：车牌限行

    设计函数，根据输入的车牌号尾数，给出对应的限行日： ``'Mon'`` 、 ``'Tue'`` 、 ``'Wed'`` 、 ``'Thu'`` 、 ``'Fri'`` 这5个字符串中的一个。

    车牌限行规则如下：

        =======  =========
         限行日    限行尾号
        =======  =========
          Mon       1和6
          Tue       2和7
          Wed       3和8
          Thu       4和9
          Fri       5和0
        =======  =========

我们已经知道输出存在5种可能性，因此我们写出函数框架，其中用 ``if ... elif ... else`` 划分为5个分支：

    ::

        def car_restriction(x):
            if ... :
                day = 'Mon'
            elif ... :
                day = 'Tue'
            elif ... :
                day = 'Wed'
            elif ... :
                day = 'Thu'
            else:
                day = 'Fri'
            return day

接下来就是给出各个分支的执行条件。根据表格中的限行规则， ``'Mon'`` 对应的限行尾号是 ``1`` 和 ``6`` 。也就是说，当尾号 ``x`` 为 ``1`` 或 ``6`` 时，就应当执行 ``day = 'Mon'`` 的分支。用代码表达 ``x`` 为 ``1`` 或 ``6`` 这个条件的话，就是：

    ::

        x == 1 or x == 6

类似地，我们可以得到其它几个分支对应的条件。将这些条件添加到函数中对应的 ``if`` 或 ``elif`` 后面就得到：

    ::

        def car_restriction(x):
            if x == 1 or x == 6 :
                day = 'Mon'
            elif x == 2 or x == 7:
                day = 'Tue'
            elif x == 3 or x == 8:
                day = 'Wed'
            elif x == 4 or x == 9:
                day = 'Thu'
            else:
                day = 'Fri'
            return day

这里有一点值得注意，5个分支中的最后一个是 ``else`` ，因此只需要4个条件，从而我们的第5个条件 ``x == 5 or x == 0`` 没有出场机会。

这是本题与 ``max2()`` 的一个关键的不同之处。在 ``max2(a, b)`` 中， ``a`` 大于 ``b`` 之外的所有情况之下，执行 ``m = b`` 都是没有问题的。但在本题中，我们仔细考察已经填上的4个条件只覆盖了 ``x`` 的8种取值，这8种取值之外的情况却远远不只是 ``x == 5 or x == 0`` 这2种。也就是说， ``else`` 的分支对应 ``day = 'Fri'`` 是不正确的。

为纠正这一错误，我们需要追加一个 ``elif`` 分支到函数中：

    ::

        def car_restriction(x):
            if x == 1 or x == 6 :
                day = 'Mon'
            elif x == 2 or x == 7:
                day = 'Tue'
            elif x == 3 or x == 8:
                day = 'Wed'
            elif x == 4 or x == 9:
                day = 'Thu'
            elif x == 5 or x == 0:
                day = 'Fri'
            else:
                ...
            return day

现在 ``else`` 对应的成了一个空分支，需要我们填上适当的内容。由于 ``else`` 对应的是除了 ``x`` 取值在10个数字之外的情况，例如多位数字 ``123`` 或是字符串 ``abc`` 之类，根本没有对应的限行日。这里我们采取一种简单的处理方法：令 ``day = None`` ，也就是令函数最后返回值为 ``None`` ，表示不存在对应的限行日。用 ``None`` 作为无法处理的情况的取值，是一种常用的做法。

    ::

        def car_restriction(x):
            if x == 1 or x == 6 :
                day = 'Mon'
            elif x == 2 or x == 7:
                day = 'Tue'
            elif x == 3 or x == 8:
                day = 'Wed'
            elif x == 4 or x == 9:
                day = 'Thu'
            elif x == 5 or x == 0:
                day = 'Fri'
            else:
                day = None
            return day

这就是 ``car_restriction()`` 函数的完成版本。

.. topic:: Exercise

    使用不同的参数验证 ``car_restriction()`` 的执行结果是否正确。请解释为什么各个条件中使用 ``or`` 来列举两种取值而不是 ``and`` ，例如，为什么 ``x == 2 or x == 7`` 而不是 ``x == 2 and x == 7`` ？

回顾一下这道题目，由于我们一开始就知道输入和输出的5种对应关系，不妨一开始就用 ``if`` 和 ``elif`` 来处理这5种 **正常情况** ，然后在 ``else`` 分支中处理除此之外的 **意外情况** 。这样就避免了忘记处理奇怪的输入。

对于 ``max2()`` ，我们在框架阶段也可以先预留3个分支。如果经过仔细分析后，我们确信只会有2种情况，可以去掉多余的判断条件。但注意，不可以去掉 ``else`` 。我们始终需要 ``else`` 分支来完成对所有情况的覆盖。缺少了 ``else`` 分支，就必然意味着我们遗漏处理了某些情况。

通过两个简单的例题，我们初步学习了用 ``if ... elif ... else ...`` 在函数内部划分多个分支，以处理多种情况的方法。总结起来是下面几条：

    * 通过分析输入与输出，确定存在多少种可能性，然后在 ``if`` 和 ``elif`` 下的代码块中写出不同可能性对应的代码
    * 用返回布尔值的函数或运算描述每个分支的执行条件， 写在 ``if`` 或 ``elif`` 后面
    * 仔细分析没有被任何 ``if`` 或 ``elif`` 后的执行条件所覆盖到的情况，在 ``else`` 下面的代码块中处理这些意外情况

显然其中的难点在于，如何分析出存在的各种可能性。后面各节就是对典型的几种分析方法的介绍。


区分数据类型
------------

上一节中的两道例题，涉及的输入或输出是相当有限的几个值，我们直接按这几个值就可以确定分支的数量和内容。一般而言，具有实用性的程序都能处理更加广泛的输入输出范围。但如果输入或输出数据能被按照某种标准分成几类，我们就可以用每个分支分别处理其中一类数据，最终覆盖到所有可能的数据范围，从而解决整个问题。

.. topic:: 实例：指定路径的修改时间

    实现一个函数，确定指定路径的修改时间。如果指定的路径是个文件夹，其修改时间等于该文件夹中最近修改的文件的修改时间。

我们试着按老办法来实现题目要求的函数。

    1. 明确问题的输入与输出

        输入是文件或文件夹的路径，输出是文件或文件夹的修改时间

    2. 确定输入与输出的数据格式

        * 输入 ``path`` ：表示文件或文件夹的字符串，例如 ``r‘C:\Windows\System32’`` 或 ``r’C:\Windows\explorer.exe’``
        * 输出 ``mtime`` ：表示修改时间的 ``datetime`` ，例如 ``datetime(2017, 10, 20, 12, 34, 56)``

        由此写出函数框架：

        ::

            def get_file_or_dir_mtime(path):
                mtime = ... path ...
                return mtime

    3. 从输出数据开始回溯

        要从 `path` 得到 `mtime` ，我们就得面临一个选择：由于 ``path`` 是函数的参数是由调用方传入的，我们无法确定 ``path`` 究竟会代表文件还是文件夹。也就是说，同时存在 ``path`` 代表文件和 ``path`` 代表文件夹这2种可能性，因此需要分别写出2种可能性对应的代码。

        假如path代表的是文件：

        ::

            mtime = get_file_mtime(path)

        假如path代表的是文件夹：::

            mtime = get_dir_mtime(path)

        为使函数能够同时容纳这2种可能性，需要 ``if ... elif .. else ...`` 出场。我们用2个分支分别处理 ``path`` 代表文件和 ``path`` 代表文件夹2种情况，再用 ``else`` 分支处理除此之外的情况。

        ::

            def get_file_or_dir_mtime(path):
                if ... ① ...:
                    mtime = get_file_mtime(path)
                elif ... ② ... :
                    mtime = get_dir_mtime(path)
                else:
                    ... ③ ...
                return mtime

        接下来需要填充①和②处的两个分支条件。为此我们需要2个函数：

            * 函数 ``isfile()`` 接受一个参数字符串 ``path`` ，返回一个布尔值，当 ``path`` 代表文件时返回 ``True`` ，否则返回 ``False``
            * 函数 ``isdir()`` 接受一个参数字符串 ``path`` ，返回一个布尔值，当 ``path`` 代表文件夹时返回 ``True`` ，否则返回 ``False``

        将 ``isfile()`` 和 ``isdir()`` 分别填入①和②的位置，得到：

        ::

            def get_file_or_dir_mtime(path):
                if isfile(path):
                    mtime = get_file_mtime(path)
                elif isdir(path):
                    mtime = get_dir_mtime(path)
                else:
                    ... ③ ...
                return mtime

        于是到了在③处填上处理其它情况的代码的时候。如果 ``path`` 所代表的既不是文件也不是文件夹，那么会是什么呢？这个问题请你思考一下。

        但既然 ``path`` 不是文件也不是文件夹，我们可以简单的认为这个 ``path`` 不在我们的服务范围之内，返回 ``None`` 来表示我们没有取到它的修改时间即可。

        ::

            def get_file_or_dir_mtime(path):
                if isfile(path):
                    mtime = get_file_mtime(path)
                elif isdir(path):
                    mtime = get_dir_mtime(path)
                else:
                    mtime = None
                return mtime

    4. 继续向前回溯

        在前两个分支中，输出 ``mtime`` 都已经回溯到了输入 ``path`` ，最后一个分支也不存在未知的值。因此函数中的所有分支都已经回溯完毕。

    5. 整理所需函数

        我们总共用到了4个函数。其中 ``isfile()`` 和 ``isdir()`` 都可以从Python标准库 ``os.path`` 中直接引用。 ``get_file_mtime()`` 和 ``get_dir_mtime()`` 需要我们自己实现。

    6. 实现所需函数

        这里就留作给你的练习题了。请注意 ``os.path`` 中的 ``getmtime()`` 并不能直接满足我们的要求， ``getmtime()`` 返回的是时间戳，而 ``get_file_mtime()`` 需要返回 ``datetime`` 。 ``get_dir_mtime()`` 的也需要返回 ``datetime`` 。

.. topic:: Exercise

    补全 ``get_file_or_dir_mtime()`` 函数，然后用各种输入验证函数能否正确执行。

回顾解题的过程，虽然这道题目中输入输出的范围都没有明确限制，但总归是文件、文件夹、其它这3类。我们就据此将问题分解得到3个小问题，然后各个击破。这里的关键在于，我们能够解决3个问题中的任何一个，因此这个拆分是正确有效的。如果拆分后的问题仍然超出我们的能力范围，就需要考虑进一步拆分或是换一种思路重新拆分。

.. topic:: Exercise

    实现函数 ``bicycle_fee()`` 来计算共享单车的车费。输入是2个值，分别代表借车时间和还车时间。车费是每小时1元，不足整小时的部分都按整小时算。

    注意借车时间和还车时间都有可能为 ``None`` ，分别表示尚未借车和尚未还车。

再强调一遍，不要漏掉 ``else`` ，并且要对 ``else`` 所处理的情况做最仔细的考虑。


分段处理数值
------------

本节介绍一种针对以数值作为输入的问题的分支构造方法。在这类问题中，通常会明确要求对不同大小的数值做不同的处理。最典型的就是数学中的分段函数，例如绝对值函数：

.. math::

    |x| =
      \begin{cases}
         x,  &  x \ge 0\\
        -x,  &  x < 0
      \end{cases}

这个公式将所有的数值以0为分界点分为两个区间，以及对应的两种计算方法：

    * 大于等于0的数值，其绝对值是它本身
    * 小于0的数值，其绝对值是它的相反数

对于任意给定的数值，必然落在这两个区间中的一个，从而可以按其中一种计算方法得到其绝对值。

用代码来表达绝对值函数的话：

    ::

        def abs_val(x):
            if x >= 0:
                ax = x
            else:
                ax = -x
            return ax

注意这里没有使用 ``elif x < 0``，而是直接用了 ``else`` 来处理 ``x < 0`` 的情况。这一方面是因为必须有 ``else`` 才能保证覆盖处理所有情况而不会遗漏，另一方面是因为本题自身的特性保证了 ``else`` 完全等价于 ``x < 0`` 的情况。

如果问题中的输入是数值，并且输出对应不同大小的输入有不同的计算方法，我们就可以考虑将输入分段为若干区间，然后在函数中的各个分支分别进行处理。请看下面的例题。

.. topic:: 实例：显示文件大小

    实现函数 ``size_with_unit()`` ，给 ``get_file_size()`` 取到的文件大小加上适当的单位。例如 ``102 KB`` ， ``29.8 MB`` ， ``3.1 GB`` 等。

.. sidebar:: 说明

    如果你还不清楚Byte、KB、MB、GB这些是什么东西，只要先记住：1KB=1024Bytes，1MB=1024KB，1GB=1024MB。

在正式开始之前，我们先用几个例子演示一下期望的程序效果。

    * 假如输入数据是 ``400`` ，也就是代表400 Bytes，程序可以直接输出 ``400 Bytes`` ；
    * 假如输入数据是 ``2048`` ，也就是2048 Bytes，程序应该输出 ``2 KB`` ；
    * 假如输入数据是 ``1920000`` ，也就是1920000 Bytes，程序应该输出 ``1.8MB`` ；
    * 假如输入数据是 ``58400000000`` ，也就是58400000000 Bytes，程序应该输出 ``58.4GB`` ；

从这几组输入输出数据的对应关系我们至少可以看出两点：

  1. 输出可能有4种单位：Bytes，KB，MB，GB
  2. 输入数据中不同大小的数值，对应输出数据中不同的单位

由于输出明确分为4种情况，这提示我们应该将输入的数值也分成4段。具体的分段标准题目中并没有明确给出，我们可以自己发挥一下，添加如下条件：

    输出结果的数值，整数部分不得多于3位。

在这个条件下，我们用下面的表格将分段标准明确化：

    ===========================================  =======
    输入数值                                      单位
    ===========================================  =======
    ``0`` - ``999``                              Bytes
    ``1000`` – ``999 * 1024``                    KB
    ``999 * 1024 + 1`` – ``999 * 1024 * 1024``   MB
    ``999 * 1024 * 1024 + 1`` – ``∞``            GB
    ===========================================  =======

细究起来，这里以GB为单位的结果整数部分可以超过3位，因为我们没有准备更大的单位。在这里就放宽条件吧。

现在开始按步骤编写程序：

    1. 明确输入输出

        输入和输出都是文件大小，但是输出带有单位

    2. 确定输入数据和输出数据的表示方法

        * 输入数据是数值 ``size`` ，例如 ``2048``
        * 输出数据是字符串 ``size_str`` ，具体又分为4种情况，例如： ``'400 Bytes'`` ， ``102 KB`` ， ``29.8 MB`` ， ``3.1 GB``

    3. 从输出数据开始回溯

        我们已经知道由于输出有4种不同情况，我们需要在函数中构造至少4个分支，并且在4个分支分别进行回溯：

        ::

            def size_with_unit(size):
                if 0 <= size <= 999 :
                    num = ... size ...
                    size_str = '{} Bytes'.format(num)
                elif 1000 <= size <= 999 * 1024 :
                    num = ... size ...
                    size_str = '{} KB'.format(num)
                elif 999 * 1024 + 1 <= size <= 999 * 1024 * 1024 :
                    num = ... size ...
                    size_str = '{} MB'.format(num)
                elif 999 * 1024 * 1024 + 1 <= size :
                    num = ... size ...
                    size_str = '{} GB'.format(num)
                else:
                    size_str = None
                return size_str

        根据前面的表格，我们很容易就能给出每个分支要处理的单位及其对应的分支条件。但由于4个分支只覆盖了自然数而非所有数值，因此我们需要 ``else`` 来处理其它情况。这里仍然是简单的令 ``size_str = None`` 。

    4. 继续回溯直到输入数据

        除了 ``else`` 分支，另外4个分支都还没有完成回溯。在每个分支上，我们都需要给出从字节数 ``size`` 得到配合单位的数值 ``num`` 的计算方法。

            * 以Bytes为单位，数值就等于字节数： ``num = size``
            * 以KB为单位，需要将字节数除以1024： ``num = size / 1024``
            * 以MB为单位，需要再次除以1024： ``num = size / 1024 / 1024``
            * 以GB为单位，需要再再次除以1024： ``num = size / 1024 / 1024 / 1024``

        将这些算式分别填入函数中的相应分支，就得到了 ``size_with_unit()`` 函数的完成版：

        ::

            def size_with_unit(size):
                if 0 <= size <= 999 :
                    num = size
                    size_str = '{} Bytes'.format(num)
                elif 1000 <= size <= 999 * 1024 :
                    num = size / 1024
                    size_str = '{} KB'.format(num)
                elif 999 * 1024 + 1 <= size <= 999 * 1024 * 1024 :
                    num = size / 1024 / 1024
                    size_str = '{} MB'.format(num)
                elif 999 * 1024 * 1024 + 1 <= size :
                    num = size / 1024 / 1024 / 1024
                    size_str = '{} GB'.format(num)
                else:
                    size_str = None
                return size_str

        没有任何需要实现的函数了。大功告成。

.. topic:: Exercise

    用不同的参数验证 ``size_with_unit()`` 的输出是否正确，并请考虑下面两个问题：

        1. 请给出适当的输入，执行函数中的 ``else`` 分支；
        2. 如果要将分支条件中的 ``<=`` 全部换成 ``<`` ，相应的分界数值应该如何修改？

本节的将输入数值分段为区间的方法，与上节的按输入输出类型分类的方法，是在函数中构造分支的两种不同思路。根据问题本身的性质，你可能需要采用其中的一种，也可能需要将二者结合使用，也可能需要思考其它更合适的分类方法。但总的方针都是一样：分支的个数是由我们使用的输入数据和输出数据的表示形式决定的，构造分支的方法也要通过对输入数据和输出数据进行仔细分析来得到。

再次强调，不要漏掉 ``else`` ，并且要对 ``else`` 所处理的情况做最仔细的考虑。

.. topic:: Exercise

    某商城进行促销优惠活动，规则是购物金额满200减10，满300减20，超过400后每满400减50，上不封顶。

    实现函数 ``on_sale()`` ，根据购物金额和上述优惠规则，计算最后实际需要支付的金额。


处理意外情况
------------

我们的程序和函数是我们对问题的理解的反映，因此我们不能指望程序自动的正确处理我们没有考虑到的情况。但有道是智者千虑必有一失，谁也无法保证总是能够完备地考虑到所有可能性。这种时候我们如何补救呢？

现在回到获取文件或文件夹修改时间的例题。假设我们当时天真的以为 ``path`` 不是文件就是文件夹，只考虑到2种情况就会写出只包含2个分支的程序：

    ::

        def get_file_or_dir_mtime_naive(path):
            if isdir(path):
                mtime = get_dir_mtime(path)
            else:
                mtime = get_file_mtime(path)
            return mtime

我们让 ``path`` 代表不存在的路径，运行程序来看看会发生什么情况。

    ::

        def main():
            path = '123.abc'
            mtime = get_file_or_dir_mtime_naive(path)
            print(mtime)

程序的运行结果将是类似下面这样：

    ::

        Traceback (most recent call last):
            File "c:\ProgrammingBasics\src\get_dir_mtime.py", line 27, in <module>
                main()
            File "c:\ProgrammingBasics\src\get_dir_mtime.py", line 24, in main
                print(get_file_or_dir_mtime_naive(path))
            File "c:\ProgrammingBasics\src\get_dir_mtime.py", line 18, in get_file_or_dir_mtime_naive
                mtime = get_file_mtime(path)
            File "C:\Python36\lib\genericpath.py", line 55, in getmtime
                return os.stat(filename).st_mtime
        FileNotFoundError: [WinError 2] 系统找不到指定的文件。: '123.abc'

类似的情况你之前也许已经遇到过，这是所谓的程序 *异常终止* 。屏幕显示的内容是异常发生的代码位置以及异常的原因。

阅读这堆异常信息的方法是从后向前回溯（恰好和我们的编程方法一样）。首先是最后一行：

    ::

        FileNotFoundError: [WinError 2] 系统找不到指定的文件。: '123.abc'

这一行解释了异常的原因。其中 ``FileNotFoundError`` 是 *异常类型* ，字面意思是文件并不存在。后面的信息也指出了这一点。

为了了解更多关于这个异常的信息，我们向前回溯：

    ::

            File "C:\Python36\lib\genericpath.py", line 55, in getmtime
                return os.stat(filename).st_mtime

这两行指出了异常发生时代码执行到的位置， ``genericpath.py`` 并不是我们的代码，所以这两行对我们意义不大。继续向前回溯：

    ::

            File "c:\Users\chao.li\Documents\Projects\ProgrammingBasics\get_dir_mtime.py", line 18, in get_file_or_dir_mtime_naive
                mtime = get_file_mtime(path)

这两行格式和内容也是一样，其中 ``get_dir_mtime.py`` 正是我们的程序文件。后面继续指出了 ``get_file_or_dir_mtime_naive`` 函数中的 ``mtime = get_file_mtime(path)`` 就是异常发生时正在执行的代码。

经过对这堆屏幕输出认真的阅读分析，我们终于了解到问题所在： ``mtime = get_file_mtime(path)`` 中的 ``path`` 代表的是不存在的路径，而我们没有考虑到这种情况。

明白这一点之后，我们就可以着手修复这个问题。除了添加 ``elif`` 分支这种方法，我们还可以用 *异常处理* 来补救这个失误。具体方法如下：

从出错信息得知异常是在 ``mtime = get_file_mtime(path)`` 这行代码执行期间发生的。为了能够捕获并处理这个异常，我们用 ``try … except …`` 包住这行代码：

    ::

        def get_file_or_dir_mtime_naive(path):
            if isdir(path):
                mtime = get_dir_mtime(path)
            else:
                try:
                    mtime = get_file_mtime(path)
                except … ① …:
                    … ② …
            return mtime

现在有两个空需要填：

    * 跟在 ``except`` 后面的①的位置是要处理的异常类型，我们在这里填上从出错信息看到的 ``FileNotFoundError``
    * 下面的代码块②中是遇到这种异常类型时对应的处理方法，这里我们还是简单的令 ``mtime = None`` ，代表我们没能获取到任何修改时间

    ::

        def get_file_or_dir_mtime_naive(path):
            if isdir(path):
                mtime = get_dir_mtime(path)
            else:
                try:
                    mtime = get_file_mtime(path)
                except FileNotFoundError:
                    mtime = None
            return mtime

这就写好了一段 *异常处理* 代码。这段代码由3部分组成：

    1. ``try`` 下面的 **代码块** ，这是可能发生异常的代码片段
    2. ``except`` 后面的 **名字** ，这是我们希望处理的异常类型
    3. ``except`` 下面的 **代码块** ，这是在异常发生时需要执行的代码片段

重新运行程序，仍然令 ``path`` 代表不存在的路径，可以看到这次程序顺利得出了 ``None`` 。

.. topic:: Exercise

    试试给 ``get_file_mtime()`` 传入文件夹作为参数，运行结果如何？给 ``get_dir_mtime()`` 传入文件作为参数呢？

更进一步，我们甚至可以用 ``try`` 来区分 ``path`` 是文件还是文件夹，从而完全不使用 ``if`` 。下面就是获取文件或文件夹修改时间的函数的另一种实现方式：

    ::

        def get_file_or_dir_mtime_v2(path):
            try:
                mtime = get_dir_mtime(path)
            except NotADirectoryError:
                mtime = get_file_mtime(path)
            except FileNotFoundError:
                mtime = None
            return mtime

这次的异常处理有2个 ``except`` 代码块，分别处理两种异常类型。除了我们已经认识的 ``FileNotFoundError`` ，新增加的 ``NotADirectoryError`` 是表示指定路径存在但并非文件夹的异常类型。如果 ``mtime = get_dir_mtime(path)`` 执行时发生了 ``NotADirectoryError`` 异常，我们就可以把 ``path`` 作为文件来处理。

可以看到在这个版本的函数中，代码同样是被分成了3块，分别处理 ``path`` 为文件夹、文件、不存在的路径这3种情况。在这个意义上，``try … except …`` 与 ``if … elif … else …`` 这两种写法的效果是等价的，都可以区分多种情况并做出相应的处理。但这两种写法的思维方式是截然相反的。使用 ``if`` 需要我们事先考虑清楚各种情况的构成条件，或者说 **原因** ；使用 ``try`` 却是根据程序实际运行后遇到的 **结果** 来判断目前处于何种状况。

.. topic:: Exercise

    分别用文件夹、文件、不存在的路径作为 ``path`` ，验证 ``get_file_or_dir_mtime_v2()`` 的运行结果是否与 ``get_file_or_dir_mtime()`` 完全一致。

传统上，使用 ``if … elif … else …`` 来在代码中构造分支是首选的做法。但如果你发现很难直接给出某种情况的构成条件，或是在程序运行后发现了没有考虑到的情况，就可以根据异常信息在程序中添加适当的 ``try … except …`` 来判断并处理这种情况。无论采用 ``if`` 还是 ``try`` 或是二者结合的写法，最后总的分支个数应该都是一样的。这是因为分支的个数是由我们使用的输入数据和输出数据的表示形式决定的。

有人会认为使用 ``try`` 的写法太过迂回，试图避免使用 ``try`` ：只要考虑到所有情况，又何必用 ``try`` 来试错？事实上这种想法不但没有必要，有时甚至会导致错误。例如在处理文件/文件夹相关的问题时，使用 ``try`` 的写法往往比使用 ``if`` 的写法更为正确。

设想这样的情况：我们向 ``get_file_or_dir_mtime()`` 函数传入一个文件路径作为参数。程序运行后会进入 ``if isfile(path):`` 所在的分支，准备执行 ``mtime = get_file_mtime(path)`` 。然而，由于函数中的代码是一行一行顺序执行的，在这两行代码执行之间存在一个短暂的时间差。如果 ``path`` 所代表的文件恰好在这个瞬间被删除， ``get_file_mtime(path)`` 的操作对象就变成了不存在的路径！这与它应该对应的条件分支是不符合的。显然使用 ``if`` 的版本在这种情况下会出错，从而我们仍然需要用 ``try`` 来处理异常。而一开始就使用 ``try`` 的版本则从根本上杜绝了发生这种情况的可能性。

.. topic:: Exercise

    请思考 ``get_file_or_dir_mtime_v2()`` 中的 ``get_file_mtime()`` 是否可能遇到上面讲的文件被删除的情况？应该如何处理？

另一方面，由于必须触发某种异常后才有 ``try … except …`` 的用武之地，在不能或不便触发异常的场合，我们还是只能使用 ``if … else … else …`` 来判断区分多种情况。例如文件大小单位的例题中，用于决定分支的数值区间是人为划分的，并不能触发异常。用 ``if … else … else …`` 来列出所有区间就是这种情况下的正确选择。

总而言之， ``if`` 和 ``try`` 两种写法都是实现分支处理的手段。根据具体问题的不同，我们选用其中更合适的一种来实现程序。没有必要厚此薄彼。

.. topic:: Exercise

    实现两个版本的求列表中数值的平均值的函数，分别使用 ``if`` 和 ``try`` 处理输入列表为空的情况。

最后补充一点，异常处理并非仅仅是分支处理的一种特殊形式，而是具有更为深刻的意义。这一点我们在几章之后会专门深入讨论。


本章小结
--------

本章的主题是多分支程序的构造方法。亦即：在何种情况下使用 ``if ... elif ... else ...`` 以及如何使用。

  * 如果输入数据或输出数据可以被划分为若干类，这就提示我们需要用 ``if ... elif ... else ...`` 来处理多种情况。我们用每个 ``if`` 或 ``elif`` 分支处理分类中的一种情况，用 ``else`` 处理不包含在前面分类中的情况。
  * 将输入数据或输出数据进行分类的具体方法是依数据本身的特性或问题的要求而定的，可能是规定的几个不同取值，可能是若干数据类型，可能是被边界值划分的若干区间，也可能是这些情况的组合。
  * 关于 ``else`` ，我们建议始终在条件分支的最后带上 ``else`` ，以处理一切意外情况。除非你完全确信不可能出现任何意外，或是意外情况不需要任何特殊处理。无论如何，对 `else` 的情况进行深思熟虑是不可缺少的必要步骤。这促使我们对问题进行更为全面深入地思考，从而避免低级失误。

本章也简要讲解了多分支程序的一种特殊形式：异常处理（ ``try ... except ...`` ）。由于只需指出结果而无需详述原因，善用异常处理可以使程序简洁清晰。但注意你仍然要对何种情况下出现何种异常深思熟虑，在一知半解的情况下滥用异常处理是极其危险的。
