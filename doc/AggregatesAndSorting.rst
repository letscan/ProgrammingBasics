.. default-role:: code


聚合与排序
==========

.. hint::

    阅读本章之前，请先确认你已经熟悉下列概念：

        函数 输入 输出 列表 过滤

    如果有任何疑问，请重新阅读前面的章节。


本章我们示范若干种聚合函数——从一组数据得到一个单一值——的实现方法，以及排序的2种实现方法。例题所实现的函数基本都是Python内置函数的简化版，如果你只是需要这些函数的功能，我们建议直接使用Python内置的版本而不要自己实现。本章真正的重点，是设计这些函数所使用的方法和思想——递归。我们认为，掌握递归是真正掌握编程的标志。


最大值
------

前面我们曾经实现了一个 `max2()` 函数，只能找出二者中较大的一个。真正的 `max()` 函数可以从任意多个值中找出最大的一个。本节我们将以 `max2()` 为基础，实现一个我们自己的 `max()` 函数。

首先回顾一下 `max2()` 函数的结构：

    ::

        def max2(a, b):
            if a > b:
                m = a
            else:
                m = b
            return m

函数中包含2个分支，这是由输出存在2种可能性决定的：在输入值只有2个的情况下，输出要么是 `a` ，要么是 `b` 。如果只是简单的延续这种思路来处理更多的输入值，那么输入值有多少个，我们的分支就要有多少个。更何况我们没法事先知道输入值究竟有多少个。

但其实只要换个思路，我们就可以认为，不论输入值有多少个，输出都只有2种可能性。

如图所示，我们把所有输入值分成2部分：第1个值 `first` ，以及剩下的所有值组成的列表 `rest` 。

然后请你仔细思考下面这个说法：

    输出要么是 `first` 本身，要么是 `rest` 中的最大值。

当你充分理解这句话之后，我们来按照这个思路写出代码：

    ::

        def max_of(values):
            first = values[0]
            rest = values[1:]
            a = first
            b = max_of(rest)
            m = max2(a, b)
        return m

这个函数的特别之处在于， `max_of()` 函数的内部，竟然使用了 `max_of()` 函数自己！

虽然初看起来可能会觉得不可理喻，但这其实一点都不奇怪。只要习惯了就好了。

当然首先我们要验证这个函数真的可以执行。不妙的是这个程序执行后很快出错。显示的异常信息类似下面这样：

    ::

        >>> max_of([1, 3, 2])
        Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        File "<stdin>", line 3, in max_of
        File "<stdin>", line 3, in max_of
        File "<stdin>", line 3, in max_of
        File "<stdin>", line 2, in max_of
        IndexError: list index out of range

这是由于我们少考虑了一种情况： `values` 中包含的值可能不到2个。好吧实际上是2种情况：

    * `values` 中只包含1个值
    * `values` 中不包含任何值（或者说包含0个值）。

参考真正的 `max()` 函数，发现当 `values` 不包含任何值时， `max()` 函数也会异常。因此我们可以先不考虑 `values` 不包含任何值的情况。

于是我们需要在函数中构造2个分支，分别处理 `values` 中只包含1个值的情况，以及 `values` 中包含2个或2个以上值的情况：

    ::

        def max_of(values):
            if len(values) == 1:
                m = values[0]
            else:
                first = values[0]
                rest = values[1:]
                a = first
                b = max_of(rest)
                m = max2(a, b)
            return m

我们在 `if` 的分支中处理只包含1个值的情况，方法自然是返回 `values` 中唯一的值。在 `else` 分支中是我们之前写好的代码，处理包含2个或2个以上值的情况。

重新运行程序，这次没有问题了。

.. topic:: 练习

    用相同的列表作为输入，对比 `max_of()` 和 `max()` 的运行结果。

回顾一下这个函数的实现方法，这个方法基于把作为输入的列表拆成2个部分分别处理，其中简单的一部分可以直接处理，复杂的一部分通过调用函数自身，继续如法炮制拆成简单与复杂2个部分，如此反复多次，直到无法继续拆分。此时（列表仅含一个元素）也是一个可以直接处理的情况。至此问题全部解决。

这个过程最核心的就是对列表进行拆分。这个拆分成功运用了2条解决问题的基本原理：

    * 首先，列表被拆分后的一部分仍然是列表，因此可以继续拆分。这就是化未知为已知。
    * 然后，在不断拆分的过程中，原先的问题被拆成了若干个可以直接解决的简单问题。这就是化繁为简。

正是由于列表被拆分后的一部分仍然是列表，因此 `max_of()` 函数内部才可以使用 `max_of()` 函数。这种在内部包含自身的结构叫做 *递归* 。

由于列表本身是递归的，因此使用递归的方法可以解决几乎所有列表相关的问题。请结合后面各节的例题，仔细体会递归的巧妙之处，然后用习题来掌握这种巧妙的方法。


累加器
------

本节我们来模拟 `sum()` ，也就是计算列表中所有数值的总和的函数。

我们仍然用递归的方法来解决这个问题。首先来考虑几种最简单的情况：

    * 没有元素的空列表，结果当然是 `0`
    * 仅包含1个元素 `e1` 的列表，结果等于 `e1` 本身
    * 仅包含2个元素 `e1` 和 `e2` 的列表，结果等于 `e1 + e2`

包含3个或3个以上元素的列表的情况，我们再一一列举下去就没完没了了。这里我们参照包含2个元素时的情况，对结果提出一个统一的描述：

    列表中所有元素的总和，等于第1个元素 `first` ，加上列表中其它元素 `rest` 的总和。

如果用代码形式描述的话就是：

    ::

        first = nums[0]
        rest = nums[1:]
        total = first + sum_of(rest)

这个最广泛性的描述，连同前面讨论过的简单情况，合在一起成为一个包含3个分支的函数：

    ::

        def sum_of(nums):
            if len(nums) == 0:
                total = 0
            elif len(nums) == 1:
                total = nums[0]
            else:
                first = nums[0]
                rest = nums[1:]
                total = first + sum_of(rest)
            return total

注意我们没有为包含2个元素的情况单独保留一个分支，请思考下这是为什么。总之 `sum_of()` 函数就这样完成了。我们用一个例子来验证一下函数的正确性。

假设输入 `nums = [1, 2, 3, 4]` ，那么根据我们的函数，整个计算推导的过程如下：

    ::

           sum_of([1, 2, 3, 4])
        == 1 + sum_of([2, 3, 4])
        == 1 + (2 + sum_of([3, 4])
        == 1 + (2 + (3 + sum_of([4]))
        == 1 + (2 + (3 + 4))
        == 1 + 2 + 3 + 4 == 10

可见结果完全正确。

通过 `sum_of()` 和 `max_of()` 这两个例子，我们可以总结出应用递归方法解决问题的基本步骤。假设我们要实现递归函数rf()：

    1. 考虑列表仅包含0个或1个元素的简单情况，直接得出结果
    2. 考虑列表包含2个元素的情况，得到计算结果所需的函数 `c()` ，也就是 `max_of()` 中的 `max2()` ，或是 `sum_of()` 中的加法运算
    3. 于是当列表包含2个或更多元素时，结果都可以由 `c(first, rf(rest))` 得到。其中 `first` 是列表中的第1个元素， `rest` 是列表中其它元素组成的列表
    4. 在函数中用分支分别处理包含0个元素的情况、包含1个元素的情况以及包含2个或更多元素的情况，递归函数就完成了

下面通过一组练习，来巩固我们刚刚学习的递归方法。

.. topic:: 练习：连接列表

    设计函数 `chain()` ，将一组列表连接成一个大的列表。例如将 `[1, 2, 3]` ， `[4, 5, 6]` ， `[7, 8, 9]` 连接成为 `[1, 2, 3, 4, 5, 6, 7, 8, 9]` 。

.. topic:: 练习：连接字符串

    设计函数 `join_lines()` ， 将一组字符串每个作为一行，连接成一个包含多行内容的字符串。例如将 `[‘How are you?’` 、 `‘Fine, Thank you. And you’` 、 `“I’m fine, too.”` 连接成 `“How are you?\nFine, Thank you. And you?\nI’m fine, too.”` 。

.. topic:: 练习：列表的长度

    设计函数 `length_of()` ，计算列表中包含的元素数量。

.. topic:: 练习：计数

    设计函数 `count_of()` ，计算指定的字符在字符串中出现了多少次。例如 `count_of(‘python program’, ‘p’)` 的结果应该是 `2` 。

.. topic:: 练习：查找

    设计函数 `index_of()` ，在列表 `items` 中找出指定的元素 `x` ，返回 `x` 在列表中的位置 `index` ，使得 `items[index] == x` 。如果列表中不存在 `x` ，则返回 `-1` 。


排序I
-----

迄今为止我们对递归方法的使用，都是把列表作为输入得到一个新的值，也就是所谓聚集。本节我们将要学习的排序，并不会从列表中得到新的东西，而仅仅是改变列表中元素的出现顺序。

这次的模仿对象是Python的内置函数 `sorted()` 。如果你还不了解 `sorted()` 的功能，请试着运行下面的代码：

    ::

        def main():
            nums = [5, 2, 3, 9, 7, 8, 1, 6, 4]
            sorted_nums= sorted(nums)
            print(sorted_items)

一切顺利的话，应该可以看到最后打印出了从小到大排序的9个数字：

    ::

        [1, 2, 3, 4, 5, 6, 7, 8, 9]

这是怎么做到的呢？作为最常用也是最重要的 *算法* 之一，数十年来计算机科学家们提出了许多种不同的实现方法。本节和下节介绍比较容易理解的两种实现。

我们的第一种排序方法，几乎照搬前面提到的递归方法。

首先考虑列表中包含0个和1个元素的情况，这两种情况都不需要真正做什么操作，直接返回原先的列表即可。

    ::

        def simple_sort(items):
            if len(items) <= 1:
                sorted_items = items
            else:
                ...
            return sorted_items

然后考虑列表中包含2个元素的情况。不论作为输入的列表是 `[1, 2]` 或者 `[2, 1]` ，我们都应该返回 `[1, 2]` 。这里需要发挥一点想象力，总结出两种情况下我们做的事情的相同之处。

因为现在并不是练习题而是例题，这里就直接给出 **一种** 答案：

    我们把列表中最小的元素放在第1位，把另一个元素放在后面。

不论列表中的2个元素是什么，我们都可以这样得到从小到大排序后的列表。对吧？

接下来该考虑更多元素的情况了。参照前述2个元素时的方法，不难想到下面的递归方法：

    我们把列表中最小的元素作为 `first` 放在第1位，把剩下的其它元素 `rest` 排序后放在后面。

把这些写成代码的话就是：

    ::

        def simple_sort(items):
            if len(items) <= 1:
                sorted_items = items
            else:
                m = min(items)
                first = [m]
                rest = [item for item in items if item != m]
                sorted_items = chain(first, simple_sort(rest))
        return sorted_items

到这里算法的主体框架已经完成了。其中引入了一个用于连接多个列表的函数 `chain()` ，在前面作为练习题出现过了。如果你还没有完成，请先完成这个函数。

很简单，不是吗？我们马上来验证一下。同样使用 `[]` 作为输入，把原版的 `sorted()` 函数换成我们的 `simple_sort()` 函数：

    ::

        def main():
            nums = [5, 2, 3, 9, 7, 8, 1, 6, 4]
            sorted_nums= simple_sort(nums)
            print(sorted_items)

运行后的结果同样是从小到大排序的9个数字：

    ::

        [1, 2, 3, 4, 5, 6, 7, 8, 9]

我们成功了吗？可惜并不尽然。我们换一组数值就会让这个算法的错误原形毕露。

    ::

        def main():
            nums = [5, 2, 3, 9, 7, 8, 2, 6, 4]
            sorted_nums= simple_sort(nums)
            print(sorted_items)

注意我们把原先列表中的 `1` 也换成了 `2` ，也就是现在有两个 `2` 。运行后的结果虽然同样是从小到大排序，但却只剩下了8个数字：

    ::

        [2, 3, 4, 5, 6, 7, 8, 9]

错误的原因在于，如果列表中存在重复的元素，则 `rest` 部分相比原列表中会过滤掉多个元素，而 `first` 部分却始终只包含1个元素，二者连接起来之后就会丢失了部分重复的元素。

想明白这一点之后，这个问题就不难修复了。

    ::

        def simple_sort(items):
            if len(items) <= 1:
                sorted_items = items
            else:
                m = min(items)
                first = [item for item in items if item == m]
                rest = [item for item in items if item != m]
                sorted_items = chain(first, simple_sort(rest))
        return sorted_items

这次我们分别用 `item == m` 和 `item != m` 作为过滤条件，构造出 `first` 和 `rest` 两个列表。对于列表中的任一元素，要么等于 `m` ，要么不等于 `m` ，因此 `first` 和 `rest` 连接起来之后必然与原列表元素个数相同。现在即使m在列表中重复出现多次，我们得到的 `first` 也会是同样个数的m组成的列表。这样输出的列表就不会缺少元素了。

重新运行程序，这次的输出果然没有问题了：

    ::

         [2, 2, 3, 4, 5, 6, 7, 8, 9]

于是，虽然经过一点小曲折，我们还是成功地应用递归方法，实现了对列表中的元素进行排序。可以看到，尽管排序函数的输出是与输入（除了元素排序之外）几乎相同的列表，聚集函数的输出是由输入列表各元素计算或组合出的单一值，但由于这两种看起来差别巨大的输出都可以被表示成 `first` 和 `rest` 从而应用递归，因此排序函数的结构与聚集函数几乎没有区别，仅仅是前者获取 `first` 和 `rest` 的过程较为复杂而已。

也就是说，即使两个问题的输入输出乍看上去迥然不同，只要我们能够将其表示成相同的形式，在这个层次上，函数的结构就仍然是由我们选择的输入输出的表示形式所决定的。

反过来讲，即使是相同的问题，输入输出完全相同，如果我们将其表示成另外一种形式，对应的函数结构也将不同，也就是同一函数的另一种实现。下一节我们就介绍排序算法的另一种实现。

.. topic:: 练习：

    设计函数 `shuffle(items)` ，输入的 `items` 是一个列表，要求输出是将 `items` 中所有元素顺序打乱后的列表。

    提示：Python标准库 `random` 中的 `choice()` 函数可以从列表中（像抽签一样）随机取出一个元素。


排序II
------

在大部分算法教科书中，类似上一节中 `simple_sort()` 函数的排序方法被称为 *简单选择排序* 。这种实现在性能方面不甚理想，假如我们用 `simple_sort()` 对包含10000个元素的列表排序需要1秒，对包含20000个元素的列表进行排序就需要大约4秒。而如果采用本节介绍的排序算法，对包含20000个元素的列表进行排序，只需要大约1.4秒。在大部分算法教科书中，本章介绍的排序方法被称为 *快速排序* 。

上一节已经预告过，新的排序方法需要我们将输出表示为另一种形式，也就是用另一种视角来看待输出列表的构成。这个独特的视角就是快速排序的精妙所在。

我们来重新观察一下已经从小到大排好序的列表：

    ::

        [1, 2, 3, 4, 5, 6, 7, 8, 9]

上一节的视角是盯住这个列表中的第一项，于是这个列表就被看作由最小值 `first` 和其它值 `rest` 两部分组成。

我们这次不再盯住第一项，而是盯住列表中部的某项，例如 `5` 。在这个视角下，列表可以被看作由3部分组成

    * 作为分界点的 `5` 本身
    * 原列表中比 `5` 小的值
    * 原列表中比 `5` 大的值

借由这个新的视角我们来探索新的排序方法。仍然拿这个未排序的列表为例：

    ::

        [5, 2, 3, 9, 7, 8, 1, 6, 4]

我们可以从中随意挑一个元素作为分界点，比如简单粗暴的用这个列表中的第一项，正好也是5。再从列表中过滤出比 `5` 小的值和比 `5` 大的值，将它们连接起来：

    ::

        chain([2, 3, 1, 4], [5], [9, 7, 8, 6])

对于新产生的两个列表我们用同样的方法处理，例如对于 `[2, 3, 1, 4]` ，我们以 `2` 作为分界点，将其分解为3部分再连接起来：

    ::

        chain([1], [2], [3, 4])

对于另一部分 `[9, 7, 8, 6]` 也是一样，取 `9` 作为分界点，得到：

    ::

        chain([7, 8, 6], [9], [])

注意这4个数中不存在大于 `9` 的值，因此第3部分为空列表。对 `[7, 8, 6]` 再做一次，以 `7` 为分界点得到：

    ::

        chain([6], [7], [8])

只要依次把它们一层层连接起来，我们就可以得到排好序的列表：

    ::

        [1, 2, 3, 4, 5, 6, 7, 8, 9]

采用这种思路写出的函数同样是递归的。处理包含0个或1个元素的输入的情况与普通的递归是一样的：

    ::

        def quick_sort(items):
            if len(items) <= 1:
                sorted_items = items
            else:
                ...
        return sorted_items

在 `else` 分支的部分，我们不再将输出表示成 `first` 和 `rest` 两部分，而是表示为小于分界点的值组成的列表 `smaller` 、等于分界点的值组成的列表 `equal` 、大于分界点的值组成的列表 `larger` 这3部分：

    ::

        def quick_sort(items):
            if len(items) <= 1:
                sorted_items = items
            else:
                pivot = items[0]
                smaller = [item for item in items if item < pivot]
                equal= [item for item in items if item == pivot]
                larger= [item for item in items if item > pivot]
                sorted_items = chain(quick_sort(smaller), equal, quick_sort(larger))
        return sorted_items

其中 `smaller` ， `equal` ， `larger` 都是简单的由原列表过滤得到。也没有任何需要实现的函数。这就是 `quick_sort()` 函数的完成版。

.. topic:: 练习

    用不同的输入验证 `quick_sort()` 函数的正确性。

.. topic:: 练习

    下面的程序可以生成包含n个数值的乱序列表，并显示 `simple_sort()` 和 `quick_sort()` 对该列表进行排序分别耗时多少。用不同的n进行试验，对比两种排序方法的耗时情况。

        ::

            import random
            import time

            def main():
                n = 10000
                nums = list(range(n))
                random.shuffle(nums)
                t0 = time.time()
                simple_sort(nums)
                t1 = time.time()
                quick_sort(nums)
                t2 = time.time()
                print('Simple Sorted in {}s'.format(t1 - t0))
                print('Quick Sorted in {}s'.format(t2 - t1))

如你所见，大部分情况下处理相同长度的列表 `quick_sort()` 总是比 `simple_sort()` 快。对这个现象进行严谨的分析超出了本书的范围。但简单说明的话， 大致是因为在应用递归方法时， `quick_sort()` 每次把问题的规模缩小一半，而 `simple_sort()` 每次只把问题规模减小一点。这种差异同样是我们从不同视角看待输出数据，进而将输出数据表示为不同形式所导致的必然结果。

话说回来，每次将问题规模缩小一半的递归虽然巧妙，但一来并非所有问题都能被如此拆解，二来即使并非人人都能找到这种巧妙的拆解方法，三来即使顺利拆解也未必能像快速排序一样有显著的性能优势或其它好处。而每次将问题规模减小一点的first-rest式递归，则是简单可靠，人人可用，用则必成。因此我们建议首先用first-rest式递归解决问题，在此基础上再去探索更优化的递归，而不要一开始就好高骛远。

.. topic:: 练习：猜数字游戏

    设计函数 `guess_number(x)` ，输入x是一个0到100之间的整数。请在函数中模拟猜数字的过程，并将过程在屏幕上显示。例如：

        ::

            32 –> too small
            80 –> too big
            75 –> bingo

    请至少基于两种不同的猜数字策略实现不同的函数，然后对比哪种方法能用更少的步骤得到正确答案。

    如果x不是0到100之间的整数，请输出报错信息。


本章小结
--------

如本章开头所说，充分理解并掌握本章所介绍的递归方法，是真正掌握编程技能的标志。其中尤其需要重点掌握的，是first-rest形式的递归。由于用列表表示的数据必然可以拆分为first-rest形式，所以first-rest适用于一切用列表表示输入数据的问题。实现first-rest形式的递归函数的要点是：

    * 考虑列表仅包含0个或1个元素时的简单情况，直接给出结果
    * 考虑列表仅包含2个元素时的情况，以此为参考将输出数据表示为由列表的第一个元素 `first` 和其它元素 `rest` 两部分得到，其中 `rest` 部分的结果由递归调用得到
    * 用2个分支分别处理上述2类情况

注意不要忘记处理列表仅包含0个或1个元素时的简单情况。

另一大类递归是除了first-rest形式以外的递归。除了我们演示的是把原问题拆解成原先规模的一半的方法，还有各种各样的方法来构造不同形式的递归。这种递归表面上是需要巧妙的构思，本质上是需要对问题的深刻洞察。请在成功运用first-rest 形式的递归后，再向更灵活更复杂的递归形式发起挑战。

无论哪种形式的递归，函数的实现都是由我们选择的输入输出数据的表示形式决定的。在这一点上，递归方法和之前介绍的各种函数设计方法都是一样的。当你能够将问题用恰当的输入输出数据形式的表示出来，写出代码只是水到渠成的事。
