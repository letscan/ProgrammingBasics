函数与参数
====================

.. hint::

    阅读本章之前，请先确认你已经熟悉下列概念： ::

        函数 输入 输出

    如果有任何疑问，请重新阅读前面的章节。



函数定义的模板
--------------------

上一章我们提到数学中的函数定义：

    *f(x)* = *x*:sup:`2`

这是一个所谓 *2次函数（quadratic function）* 。我们不妨给这个函数换个名字：

    *quad(x)* = *x*:sup:`2`

而在Python中，这个函数的函数定义是这样的：

.. code-block :: python

    def quad(x):
        y = x ** 2
        return y

.. sidebar :: 说明

    其中 ``**`` 是Python中的乘方运算符。单独一个 ``*`` 则是表示乘号。

观察这个函数定义： ``def`` 后面是函数的名字，再后面的 ``()`` 之间是函数的输入，又叫做 *参数* 。最后一行的 ``return`` 后面是函数的输出，又叫做 *返回值* 。第一行和最后一行之间是从输入到输出的转换过程。我们把这个结构写成模板：

.. code-block:: python

    def function_name(param):
        ...
        result = ...
        return result

需要说明的是，参数并非只能有1个。比如我们来定义2次函数的标准形式：

    *f(x)* = a\ *x*:sup:`2` + b\ *x* + c

虽然数学上通常不会把 ``a`` 、 ``b`` 、 ``c`` 写到等号左边，但我们可以把 ``a`` 、 ``b`` 、 ``c`` 也作为函数的输入数据：

.. code-block:: python

    def quad(x, a, b, c):
        y = a * x ** 2 + b * x + c
        return y

另外，函数的返回值也并非只能有1个，比如我们可以定义一个 *整除函数*：

.. code-block:: python

    def div_int(a, b):
        q = a // b
        r = a % b
        return q, r

.. sidebar:: 说明

    其中 ``//`` 是Python中的整除取商运算符， ``%`` 是Python中的整除取余数运算符。

参数的 ``a`` 和 ``b`` 分别是被除数和除数，返回值的 ``q`` 和 ``r`` 分别是商和余数。

.. topic:: Exercise 1

    把上面的2次函数和整除函数放进程序模板，试着用不同的参数运行它们，观察结果是否正确。

    **提示：** 可以用 ``print`` 在屏幕上显示函数的返回值，但注意删掉上一章我们自己实现的 ``print`` 函数，因为Python语言自带了一个更完善的

考虑多个参数和多个返回值的情况，函数定义的模板应该是下面这样：

.. code-block:: python

    def function_name(param1, param2, ...):
        ...
        result1 = ...
        result2 = ...
        ...
        return result1, result2, ...

现在来解释一下上一章最后关于 ``print`` 函数的输出的思考题。把 ``print`` 的函数定义和函数定义模板进行比较，可以发现 ``print`` 函数缺少了最后的 ``return ...`` 。

但这并不代表 ``print`` 函数没有返回值。事实上这种情况下，Python语言会默认函数最后有一句 ``return None`` 。这里的 ``None`` 是一个名字，代表一个特殊的值： **什么也不是** 。这是一个自相矛盾的概念，但它的确是一个值。以后你会逐渐熟悉 ``None`` 的各种神奇作用。

也就是说， ``print`` 函数的输出正是这个神奇的值 ``None`` ，而不是其它任何东西，自然也不是屏幕上显示的文字。


字符串与列表
--------------------

上一章提到过，程序中的函数是从数学中借来的概念。因此上一节的例子也都是数字相关的例子。但程序中的函数是可以处理各种东西的，只要你能够用名字来代表。

我们给 ``print`` 函数的参数是各种文字，在程序世界中通称 *字符串* 。我们已经见过不少字符串

.. code-block:: python

    'Hello, world!\n'

    '我要学编程'

我们在程序中写下的各种文字，有些是 *名字* ，有些却是字符串（ *值* ）。区别在于字符串被一对引号所包裹。

.. topic :: Exercise 2

    引号有多种（中文、英文、单引号、双引号）。通过试验观察，不同的引号有什么不同的效果。

字符串就是由引号包裹起来的一些字符。还记得 ``'Hello, world!\n'`` 里面的 ``\n`` 吗？ ``\`` 和紧随其后的 ``n`` 看起来是2个字符，实际却只代表1个字符 *换行符* (按回车键的效果）。类似的还有 ``\t`` 代表 *制表符* （按Tab键的效果）。由于 ``\`` 有这样的特殊功能，如果我们的文字本身就包含 ``\`` 符号，比如Windows的文件路径，就需要把字符串写成这样：

.. code-block:: python

    'C:\\Windows\\System32\\abc.txt'

或者可以这样写：

.. code-block:: python

    r'C:\Windows\System32\abc.txt'

很多程序里都有类似的表示方法。这里就有一个问题：引号之间写下的字符数，并不是字符串实际包含的字符数。

我们可以把字符串实际包含的字符数定义为字符串的 *长度* 。Python语言提供了一个函数来计算字符串的长度，因此我们不需要亲自小心仔细的去数：

.. code-block:: python

    text = 'C:\\Windows\\System32\\abc.txt'
    n = len(text)

很显然这里 ``len`` 函数的输入是一个字符串，而输出是一个数字。

.. topic :: Exercise 3

    把关于 ``len`` 函数的代码放进程序模板，试着用不同的字符串来运行，观察结果与你数数的结果是否一致。

事实上 ``len`` 函数的输入不仅可以是字符串。看下面的代码：

.. code-block:: python

    chars = ['a', 'b', 'c', 'd', 'e']
    n = len(chars)

这里出现了一种新的数据格式，即 ``[]`` 之间用 ``,`` 分隔的多个字符串。这种数据格式叫做 *列表* ，自身是一个值，内部又包含多个其它的值。我们经常用列表来把相关的多个数据表示为一个整体。列表中的每个数据叫做列表的一个 *元素* 。列表中元素的个数就是列表的 *长度* 。

除了都可以作为 ``len`` 函数的参数来计算长度，列表和字符串还有很多相同之处。这里只再举一个例子：

.. code-block:: python

    text = ['abcde']
    t1 = text[2]
    t2 = text[1:3]
    t3 = text[:3]
    t4 = text[1:]
    t5 = text[:]

    chars = ['a', 'b', 'c', 'd', 'e']
    c1 = chars[2]
    c2 = chars[1:3]
    c3 = chars[:3]
    c4 = chars[1:]
    c5 = chars[:]

.. topic:: Exercise 4

    把上面的代码放进程序模板，观察运行结果，试着找出运行结果与 ``[]`` 中的数字的对应规律。

正如你观察到的，在 ``[]`` 填入一个数字，可以从字符串取出一个字符，或是从列表中取出一个元素。而 ``[:]`` 的写法，可以从字符串中取出多个字符（也就是另一个字符串），或是从列表中取出多个元素（也就是另一个列表）。而且你可能也观察到了，这个对应关系与字符在字符串中的位置，或是元素在列表中的位置有关，只不过你需要从0开始数数，而不是从1开始。这是程序世界里的一个传统。

我们还要特意提醒你注意一下： ``len`` 函数可以将字符串或列表转换为数字，而 ``[]`` 可以将数字转换为字符串或列表。请记住这个事实。


参数的名字与值
--------------------

在我们使用函数时，数据是如何进入函数内部的呢？

以前面的整除函数为例。当你写下 ``div_int(27, 5)``，就相当于在 ``div_int`` 函数内部添加了两行代码：

.. code-block:: python

    def div_int(a, b):
        a = 27
        b = 5
        q = a // b
        r = a % b
        return q, r

可见函数定义中的参数也是名字，只是它们的值是在我们使用函数时才决定的。之所以 ``27`` 对应到 ``a`` ，``5`` 对应到 ``b`` ，这完全是按照函数定义中的参数顺序来决定的。

我们再来试试一些另类玩法：

.. code-block:: python

    q, r = div_int(27, b=5)
    q, r = div_int(a=27, b=5)
    q, r = div_int(b=5, a=27)

这几种写法中，我们明确指定了全部或部分值与名字的对应关系。如果全部明确指定对应关系的话，值的顺序就可以与函数定义中名字的顺序不同。

函数参数的名字与值的对应关系，上面这些只是一般规则。还有一些函数会对参数的名字与值的对应关系有特殊规定。我们以Python内置的 ``max`` 函数为例：

.. code-block:: python

    numbers = [1, 8, 7, 2, 6]
    biggest = max(numbers)

.. topic:: Exercise 5

    把上面的代码放进程序模板，观察运行结果，然后说明 ``max`` 函数的输入、输出和功能

你大概已经猜到 ``max`` 函数的功能就是找出一批数字中最大的一个。这的确是 ``max`` 函数的功能之一，但并非全部。

请再试试下面的代码：

.. code-block:: python

    cards = ['9988', 'AAAA2', 'KQ3']
    biggest = max(cards)

这里我们假设列表中的元素是几位玩家手中的扑克牌，而规则是手中牌张数越多就算越大。运行程序后可以发现，虽然程序可以正常运行，但结果并不符合我们的预期。

原因在于列表 ``cards`` 中的元素并非数字，而 ``max`` 函数并不了解我们的扑克游戏规则，无从判断这几个元素谁大谁小。我们需要有一个途径告诉 ``max`` 函数，判断“大小”的标准是牌的数量（在这里就是字符串的长度）。正好 ``max`` 函数提供了 ``key`` 参数来让我们指定规则：

.. code-block:: python

    cards = ['9988', 'AAAA2', 'KQ3']
    biggest = max(cards, key=len)

再次运行程序，结果符合预期。这里的关键就在于 ``key=len`` ：我们可以给 ``max`` 函数的参数 ``key`` 指定一个函数作为值，只要这个函数可以把列表中的每个元素转换为一个数字，然后 ``max`` 函数就可以用转换出的数字作为对应元素的大小，从而决定所有元素的最大者。在扑克牌例子中，列表中的每个元素都是字符串， ``len`` 函数可以把字符串转换为数字（字符串长度），从而 ``max`` 函数就可以用字符串长度来判定字符串的“大小”。

然而 ``max`` 函数的 ``key`` 参数有一个独特之处。在类似整除函数的例子中，我们使用函数时只要按与函数定义中一样的顺序写出各个参数即可，但如果你不写出 ``key`` 参数的名字：

.. code-block:: python

    cards = ['9988', 'AAAA2', 'KQ3']
    biggest = max(cards, len)

程序只会抛出一堆奇怪的文字，而不会给出我们期望的结果。这种情况叫做 *程序异常* ，原因是 ``max`` 函数规定了如果你要使用 ``key`` 参数，就必须明确写出 ``key`` 参数的名字。为什么要设置这条规定，我们以后再解释。目前只需要知道，某些函数参数在使用时是必须明确写出名字的。

.. topic:: Exercise 6

    注意到了吗？程序和函数都有输入和输出，请思考程序和函数之间的关系。


他山之石
--------------------

有道是他山之石，可以攻玉。正如我们在写文章时经常需要引用别人的作品，编写程序时也经常需要引用别人的程序。

例如我们已经见过的 ``stdout`` ，这个代表屏幕显示的名字是从何而来的呢？你也许已经注意到了：

.. code-block:: python

    from sys import stdout

这又是一种引入名字的形式，一般称之为 *引用（import）* 。上面这行代码表示我们从Python标准库中的 ``sys`` *模块* 引用了名字 ``stdout`` 。

像茴字一样， *引用（import）* 有4种写法：

.. code-block:: python

    import sys
    import os.path as path_util
    from sys import stdout
    from os.path import getsize as get_file_size

四种写法分别大致相当于：

    sys = 名为 ``'sys'`` 的模块

    path_util = 名为 ``'os.path'`` 的模块

    stdout = 名为 ``'sys'`` 的模块中的名字 ``stdout`` 所代表的值

    get_file_size = 名为 ``'os.path'`` 的模块中的名字 ``getsize`` 所代表的值

也就是说，引用（import）相当于在我们的程序里定义一些名字，这些名字所代表的值来自 *模块* 。

关于*模块* 的精确定义，现在还没有必要纠结。目前我们简单理解 *模块* 有下面2种：

 1. 别人已经写好的程序，包括 *Python标准库* 和 *第三方库* ，这些模块的名称你需要事先了解

 2. 我们自己的其它程序，这种情况要求你把被引用程序的 ``.py`` 文件和我们正在写的程序的 ``.py`` 文件放在同一目录，而模块的名称就是被引用程序的文件名去掉 ``.py`` 。

提高编程效率的秘诀之一就是尽可能多利用已经写好的程序，不论自己的还是别人的。编程水平的提升，在掌握基本方法之后，可以说完全取决于对别人程序（Python标准库和第三方可）的熟悉程度。

而且，某些问题如果不使用Python标准库中已有的程序，我们自己几乎不可能解决。例如要在屏幕上显示文字，如果不利用 ``stdout`` ，我们自己是完全无法实现的。

下面列出另外一些Python标准库中非常有用的函数：

.. code-block:: python

    import time
    from datetime import date
    from os import listdir
    from os.path import getsize as get_file_size

    today = date.today()
    dir_paths = listdir('C:\\Windows')
    file_size = get_file_size('C:\\Windows\\explorer.exe')

    print('Sleeping...')
    start = time.time()
    time.sleep(5)
    print(time.time() - start)

这些函数以后会经常用到，现在就开始熟悉它们吧。

.. topic:: Exercise 7

    观察上面引用的这些函数的运行结果，说明它们的输入和输出。
